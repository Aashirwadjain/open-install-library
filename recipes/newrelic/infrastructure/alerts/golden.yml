name: alerts-golden-signal
displayName: Golden Signal Alerts
description: New Relic install recipe for golden signal alerts
repository: https://github.com/newrelic/newrelic-cli

installTargets:
  - type: host
    os: linux

keywords:
  - Alerts
  - Golden

processMatch: []

preInstall:
  info: |2
      This installation will setup a Golden Signals alert policy with the below conditions:
      - High CPU
      - High Application Error Rate
      - High Application Response Time
      - Low Application Throughput

install:
  version: "3"
  silent: true

  tasks:
    default:
      cmds:
        - task: setup

    setup:
      cmds:
        - |
          NEW_RELIC_API_URL=$(echo -n 'https://api.newrelic.com')
          NEW_RELIC_INFRA_API_URL=$(echo -n 'https://infra-api.newrelic.com')
          if [ $(echo {{.NEW_RELIC_REGION}} | grep -i staging | wc -l) -gt 0 ]; then
            NEW_RELIC_API_URL=$(echo -n 'https://staging-api.newrelic.com')
            NEW_RELIC_INFRA_API_URL=$(echo -n 'https://staging-infra-api.newrelic.com')
          fi
          if [ $(echo {{.NEW_RELIC_REGION}} | grep -i eu | wc -l) -gt 0 ]; then
            NEW_RELIC_API_URL=$(echo -n 'https://api.eu.newrelic.com')
            NEW_RELIC_INFRA_API_URL=$(echo -n 'https://infra-api.eu.newrelic.com')
          fi

          NEW_RELIC_ALERT_POLICY_URL=$(echo -n $NEW_RELIC_API_URL'/v2/alerts_policies.json')
          POLICY_RESULT=$(curl -sX GET $NEW_RELIC_ALERT_POLICY_URL \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' -H 'Auth-Type:User-Api-Key' \
              -H 'Content-Type: application/json'
          )
          POLICY_ID=$(echo $POLICY_RESULT | newrelic utils jq '.policies[] | select(.name=="{{.ALERT_POLICY_NAME}}") | .id')
          if [ -n "$POLICY_ID" ] && [ $POLICY_ID -gt 0 ] ; then
            echo 'Alert policy found for {{.ALERT_POLICY_NAME}} name'
          else
            echo 'No existing alert policy {{.ALERT_POLICY_NAME}} found, creating alert policy {{.ALERT_POLICY_NAME}}...'
            if [ -f policy.json ]; then
              rm -f policy.json
            fi
            sudo tee -a policy.json > /dev/null <<"EOT"
          {
            "policy": {
              "incident_preference": "PER_POLICY",
              "name": "ALERT_POLICY_NAME"
            }
          }
          EOT
            sed -i 's/ALERT_POLICY_NAME/{{.ALERT_POLICY_NAME}}/g' policy.json
            POLICY_RESULT=$(curl -sX POST $NEW_RELIC_ALERT_POLICY_URL \
                -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' -H 'Auth-Type:User-Api-Key' \
                -H 'Content-Type: application/json' \
                -L -d @policy.json
                )
            POLICY_ID=$(echo $POLICY_RESULT | newrelic utils jq '.policy.id')
            if [ -n "$POLICY_ID" ] && [ $POLICY_ID -gt 0 ] ; then
              echo 'done'
            else
              echo 'Could not create a new alert policy for {{.ALERT_POLICY_NAME}} got POLICY_ID:'$POLICY_ID >> /dev/stderr
              exit 10
            fi
          fi


          if [ -f conditionsSearch.json ]; then
            rm -f conditionsSearch.json
          fi
          sudo tee -a conditionsSearch.json > /dev/null <<"EOT"
          {
            "query": "{actor {account(id: {{.NEW_RELIC_ACCOUNT_ID}}) {alerts {nrqlConditionsSearch {totalCount nrqlConditions { description name id enabled expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } nrql { query } policyId runbookUrl signal { aggregationWindow fillOption evaluationOffset fillValue } terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds ... on AlertsNrqlBaselineCondition { id name nrql { query } baselineDirection description enabled expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } policyId runbookUrl signal { aggregationWindow evaluationOffset fillOption fillValue } terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } } }"
          }
          EOT
          CONDITIONS_LOOKUP_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d @conditionsSearch.json
          )


          HIGH_CPU_CONDITION_ID=$(echo $CONDITIONS_LOOKUP_RESULT | newrelic utils jq '.data.actor.account.alerts.nrqlConditionsSearch.nrqlConditions[] | select(.name=="{{.ALERT_HIGH_CPU_CONDITION_NAME}}") | .id | tonumber')
          if [ -f condition.json ]; then
            rm -f condition.json
          fi
          if [ -n "$HIGH_CPU_CONDITION_ID" ] && [ $HIGH_CPU_CONDITION_ID -gt 0 ] ; then
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionStaticUpdate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, id: CONDITION_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 85 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 valueFunction: SINGLE_VALUE }) { id name } }"
          }
          EOT
          else
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionStaticCreate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, policyId: POLICY_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 85 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 valueFunction: SINGLE_VALUE }) { id name } }"
          }
          EOT
          fi
          sed -i 's/POLICY_ID/'$POLICY_ID'/g' condition.json
          sed -i "s/CONDITION_NAME/\"\"{{.ALERT_HIGH_CPU_CONDITION_NAME}}\"\"/g" condition.json
          sed -i "s/CONDITION_ID/\"\"$HIGH_CPU_CONDITION_ID\"\"/g" condition.json
          sed -i "s/NRQL_QUERY/\"\"SELECT average(\`host.cpuPercent\`) FROM Metric FACET entity.guid, host.hostname\"\"/g" condition.json
          sed -i 's/""/\\"/g' condition.json
          echo 'Adding alert condition {{.ALERT_HIGH_CPU_CONDITION_NAME}}...'
          CONDITIONS_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d @condition.json
          )
          echo 'done'


          HIGH_ERROR_CONDITION_ID=$(echo $CONDITIONS_LOOKUP_RESULT | newrelic utils jq '.data.actor.account.alerts.nrqlConditionsSearch.nrqlConditions[] | select(.name=="{{.ALERT_HIGH_ERROR_RATE_NAME}}") | .id | tonumber')
          if [ -f condition.json ]; then
            rm -f condition.json
          fi
          if [ -n "$HIGH_ERROR_CONDITION_ID" ] && [ $HIGH_ERROR_CONDITION_ID -gt 0 ] ; then
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineUpdate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, id: CONDITION_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: UPPER_ONLY }) { id name } }"
          }
          EOT
          else
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineCreate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, policyId: POLICY_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: UPPER_ONLY }) { id name } }"
          }
          EOT
          fi
          sed -i 's/POLICY_ID/'$POLICY_ID'/g' condition.json
          sed -i "s/CONDITION_NAME/\"\"{{.ALERT_HIGH_ERROR_RATE_NAME}}\"\"/g" condition.json
          sed -i "s/CONDITION_ID/\"\"$HIGH_ERROR_CONDITION_ID\"\"/g" condition.json
          sed -i "s/NRQL_QUERY/\"\"FROM Metric SELECT count(apm.service.error.count) \/ count(apm.service.transaction.duration) as 'Error Rate' WHERE appName LIKE '%' FACET entity.guid, appName\"\"/g" condition.json
          sed -i 's/""/\\"/g' condition.json
          echo 'Adding alert condition {{.ALERT_HIGH_ERROR_RATE_NAME}}...'
          CONDITIONS_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d @condition.json
          )
          echo 'done'


          HIGH_RESPONSE_CONDITION_ID=$(echo $CONDITIONS_LOOKUP_RESULT | newrelic utils jq '.data.actor.account.alerts.nrqlConditionsSearch.nrqlConditions[] | select(.name=="{{.ALERT_HIGH_RESPONSE_TIME_NAME}}") | .id | tonumber')
          if [ -f condition.json ]; then
            rm -f condition.json
          fi
          if [ -n "$HIGH_RESPONSE_CONDITION_ID" ] && [ $HIGH_RESPONSE_CONDITION_ID -gt 0 ] ; then
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineUpdate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, id: CONDITION_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: UPPER_ONLY }) { id name } }"
          }
          EOT
          else
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineCreate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, policyId: POLICY_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: UPPER_ONLY }) { id name } }"
          }
          EOT
          fi
          sed -i 's/POLICY_ID/'$POLICY_ID'/g' condition.json
          sed -i "s/CONDITION_NAME/\"\"{{.ALERT_HIGH_RESPONSE_TIME_NAME}}\"\"/g" condition.json
          sed -i "s/CONDITION_ID/\"\"$HIGH_RESPONSE_CONDITION_ID\"\"/g" condition.json
          sed -i "s/NRQL_QUERY/\"\"SELECT average(newrelic.goldenmetrics.apm.application.responseTimeMs) FROM Metric FACET entity.guid, appName\"\"/g" condition.json
          sed -i 's/""/\\"/g' condition.json
          echo 'Adding alert condition {{.ALERT_HIGH_RESPONSE_TIME_NAME}}...'
          CONDITIONS_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d @condition.json
          )
          echo 'done'


          LOW_THROUGHPUT_CONDITION_ID=$(echo $CONDITIONS_LOOKUP_RESULT | newrelic utils jq '.data.actor.account.alerts.nrqlConditionsSearch.nrqlConditions[] | select(.name=="{{.ALERT_LOW_THROUGHPUT_NAME}}") | .id | tonumber')
          if [ -f condition.json ]; then
            rm -f condition.json
          fi
          if [ -n "$LOW_THROUGHPUT_CONDITION_ID" ] && [ $LOW_THROUGHPUT_CONDITION_ID -gt 0 ] ; then
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineUpdate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, id: CONDITION_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: LOWER_ONLY expiration: { closeViolationsOnExpiration: true expirationDuration: 600 openViolationOnExpiration: true } }) { id name } }"
          }
          EOT
          else
            sudo tee -a condition.json > /dev/null <<"EOT"
          {
            "query": "mutation {alertsNrqlConditionBaselineCreate(accountId: {{.NEW_RELIC_ACCOUNT_ID}}, policyId: POLICY_ID, condition: { name: CONDITION_NAME enabled: true nrql: { query: NRQL_QUERY } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 3 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 2592000 baselineDirection: LOWER_ONLY expiration: { closeViolationsOnExpiration: true expirationDuration: 600 openViolationOnExpiration: true } }) { id name } }"
          }
          EOT
          fi
          sed -i 's/POLICY_ID/'$POLICY_ID'/g' condition.json
          sed -i "s/CONDITION_NAME/\"\"{{.ALERT_LOW_THROUGHPUT_NAME}}\"\"/g" condition.json
          sed -i "s/CONDITION_ID/\"\"$LOW_THROUGHPUT_CONDITION_ID\"\"/g" condition.json
          sed -i "s/NRQL_QUERY/\"\"SELECT average(\`newrelic.goldenmetrics.apm.application.throughput\`) FROM Metric FACET entity.guid, appName\"\"/g" condition.json
          sed -i 's/""/\\"/g' condition.json
          echo 'Adding alert condition {{.ALERT_LOW_THROUGHPUT_NAME}}...'
          CONDITIONS_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d @condition.json
          )
          echo 'done'


          USER_EMAIL_RESULT=$(curl -sX POST $NEW_RELIC_API_URL'/graphql' \
              -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
              -L -H 'Content-Type: application/json' \
              -d '{ "query": "{ actor { user { email } } }" }'
          )

          USER_EMAIL=$(echo $USER_EMAIL_RESULT | newrelic utils jq '.data.actor.user.email')
          USER_EMAIL=$(echo -n "$USER_EMAIL" | sed s/^\"//g | sed s/\"\$//g)

          NEW_RELIC_ASSUME_YES="{{.NEW_RELIC_ASSUME_YES}}"
          NEW_RELIC_EMAIL_CONTINUE="Y"
          if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
            while :; do
              echo -n "Would you like to be notified on your registered email address "$USER_EMAIL" when this alert triggers Y/N (default: Y)? "
              read answer
              echo ""
              NEW_RELIC_EMAIL_CONTINUE=$(echo "${answer^^}" | cut -c1-1)
              if [[ -z "$NEW_RELIC_EMAIL_CONTINUE" ]]; then
                NEW_RELIC_EMAIL_CONTINUE="Y"
              fi
              if [[ "$NEW_RELIC_EMAIL_CONTINUE" == "N" ]]; then
                break
              fi
              if [[ "$NEW_RELIC_EMAIL_CONTINUE" == "Y" ]]; then
                break
              fi
              echo -e "Please type Y or N only."
            done
          fi
          if [[ "$NEW_RELIC_EMAIL_CONTINUE" == "Y" ]]; then

            NEW_RELIC_ALERT_CHANNEL_URL=$(echo -n $NEW_RELIC_API_URL'/v2/alerts_channels.json')
            NEW_RELIC_ALERT_POLICY_CHANNEL_URL=$(echo -n $NEW_RELIC_API_URL'/v2/alerts_policy_channels.json')

            CHANNEL_RESULT=$(curl -sX GET $NEW_RELIC_ALERT_CHANNEL_URL'?limit1000' \
                -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
                -H 'Content-Type: application/json'
            )

            JQ_MATCH=$(echo -n '.channels[] | select(.name=="'$USER_EMAIL'" and .type=="email") | .id')
            EXEC=$(echo "echo -n '$CHANNEL_RESULT' | newrelic utils jq '"$JQ_MATCH"'")
            if [ -f execJq.sh ]; then
              rm -f execJq.sh
            fi
            echo $EXEC > execJq.sh
            CHANNEL_ID=$(bash execJq.sh)

            if [ -n "$CHANNEL_ID" ] && [ $CHANNEL_ID -gt 0 ] ; then
              echo 'Notification channel found for email address '$USER_EMAIL
            else
              echo 'Notification channel not found for email address '$USER_EMAIL', creating notification channel...'

              if [ -f channel.json ]; then
                rm -f channel.json
              fi
              sudo tee -a channel.json > /dev/null <<"EOT"
          {
            "channel": {
              "name": "CHANNEL_NAME",
              "type": "email",
              "configuration": {
                "recipients" : "RECIPIENT_NAME",
                "include_json_attachment" : true
              }
            }
          }
          EOT
              sed -i 's/CHANNEL_NAME/'$USER_EMAIL'/g' channel.json
              sed -i 's/RECIPIENT_NAME/'$USER_EMAIL'/g' channel.json
              CHANNEL_RESULT=$(curl -sX POST $NEW_RELIC_ALERT_CHANNEL_URL \
                  -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
                  -H 'Content-Type: application/json' \
                  -d @channel.json)
              CHANNEL_ID=$(echo $CHANNEL_RESULT | newrelic utils jq '.channels[] | .id')
              echo 'done'
            fi

            if [ -n "$CHANNEL_ID" ] && [ $CHANNEL_ID -gt 0 ] ; then
              echo 'Subscribing alert policy to notification channel...'
              POLICY_CHANNEL_RESULT=$(curl -sX PUT $NEW_RELIC_ALERT_POLICY_CHANNEL_URL \
                  -H 'Api-Key:{{.NEW_RELIC_API_KEY}}' \
                  -H 'Content-Type: application/json' \
                  -G -d 'policy_id='$POLICY_ID'&channel_ids='$CHANNEL_ID
                  )
              echo 'done'
            fi

          fi

      vars:
        ALERT_POLICY_NAME:
          sh: echo 'Golden Signals'
        ALERT_HIGH_CPU_CONDITION_NAME:
          sh: echo 'High CPU'
        ALERT_HIGH_ERROR_RATE_NAME:
          sh: echo 'High Application Error percentage'
        ALERT_HIGH_RESPONSE_TIME_NAME:
          sh: echo 'High Application Response Time'
        ALERT_LOW_THROUGHPUT_NAME:
          sh: echo 'Low Application Throughput'

